<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ output extension=".generated.cs" #>
<#@ include file="..\..\General.ttinclude" #>

using System;
using System.Collections.Generic;

using iSynaptic.Commons.Collections.Generic;

namespace iSynaptic.Commons
{
	public static partial class FuncExtensions
	{
		<# foreach(var i in Enumerable.Range(1, 16))
		{
			string typeArgs = Delimit(Enumerable.Range(1, i), ", ", x => "T" + x.ToString());
			string args = Delimit(Enumerable.Range(1, i), ", ", x => "t" + x.ToString());
	    #>

		public static Action<<#= typeArgs #>> ToAction<<#= typeArgs #>, TRet>(this Func<<#= typeArgs #>, TRet> self)
        {
            Guard.NotNull(self, "self");
            return (<#= args #>) => self(<#= args #>);
        }

		public static Func<<#= typeArgs #>, TResult> MakeConditional<<#= typeArgs #>, TResult>(this Func<<#= typeArgs #>, TResult> self, Func<<#= typeArgs #>, bool> condition)
        {
            return MakeConditional(self, condition, null);
        }

        public static Func<<#= typeArgs #>, TResult> MakeConditional<<#= typeArgs #>, TResult>(this Func<<#= typeArgs #>, TResult> self, Func<<#= typeArgs #>, bool> condition, TResult defaultValue)
        {
            return MakeConditional(self, condition, (<#= args #>) => defaultValue);
        }

        public static Func<<#= typeArgs #>, TResult> MakeConditional<<#= typeArgs #>, TResult>(this Func<<#= typeArgs #>, TResult> self, Func<<#= typeArgs #>, bool> condition, Func<<#= typeArgs #>, TResult> falseFunc)
        {
            Guard.NotNull(self, "self");
            Guard.NotNull(condition, "condition");

            return (<#= args #>) =>
            {
                if (condition(<#= args #>))
                    return self(<#= args #>);

                if (falseFunc != null)
                    return falseFunc(<#= args #>);
                
                return default(TResult);
            };
        }

		public static Func<<#= typeArgs #>, TResult> Synchronize<<#= typeArgs #>, TResult>(this Func<<#= typeArgs #>, TResult> self)
        {
            return self.Synchronize((<#= args #>) => true);
        }

        public static Func<<#= typeArgs #>, TResult> Synchronize<<#= typeArgs #>, TResult>(this Func<<#= typeArgs #>, TResult> self, Func<<#= typeArgs #>, bool> needsSynchronizationPredicate)
        {
            Guard.NotNull(self, "self");
            Guard.NotNull(needsSynchronizationPredicate, "needsSynchronizationPredicate");

            var lockObject = new object();

            return (<#= args #>) =>
            {
                if(needsSynchronizationPredicate(<#= args #>))
                {
                    lock (lockObject)
                    {
                        return self(<#= args #>);
                    }
                }

                return self(<#= args #>);
            };
        }

		<# } #>

		<# foreach(var i in Enumerable.Range(1, 7))
		{
			string typeArgs = Delimit(Enumerable.Range(1, i), ", ", x => "T" + x.ToString());
			string args = Delimit(Enumerable.Range(1, i), ", ", x => "t" + x.ToString());
			string fromTupleArgs = Delimit(Enumerable.Range(1, i), ", ", x => "x.Item" + x.ToString());
	    #>

		public static Func<<#= typeArgs #>, TResult> Memoize<<#= typeArgs #>, TResult>(this Func<<#= typeArgs #>, TResult> self)
		{
			Guard.NotNull(self, "self");
			var dictionary = new LazySelectionDictionary<Tuple<<#= typeArgs #>>, TResult>(x => self(<#= fromTupleArgs #>));

			return (<#= args #>) => dictionary[Tuple.Create(<#= args #>)];
		}
		<# } #>

	}
}
