<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ output extension=".generated.cs" #>
<#@ include file="..\..\General.ttinclude" #>

using System;
using System.Collections.Generic;

using iSynaptic.Commons.Collections.Generic;

namespace iSynaptic.Commons
{
	public static partial class FuncExtensions
	{
		<# foreach(var i in Enumerable.Range(1, 16))
		{
			string typeArgs = Delimit(Enumerable.Range(1, i), ", ", x => "T" + x.ToString());
			string args = Delimit(Enumerable.Range(1, i), ", ", x => "t" + x.ToString());
	    #>

		public static Action<<#= typeArgs #>> ToAction<<#= typeArgs #>, TRet>(this Func<<#= typeArgs #>, TRet> self)
        {
            Guard.NotNull(self, "self");
            return (<#= args #>) => self(<#= args #>);
        }

		public static Func<<#= typeArgs #>, TResult> MakeConditional<<#= typeArgs #>, TResult>(this Func<<#= typeArgs #>, TResult> self, Func<<#= typeArgs #>, bool> condition)
        {
            return MakeConditional(self, condition, null);
        }

        public static Func<<#= typeArgs #>, TResult> MakeConditional<<#= typeArgs #>, TResult>(this Func<<#= typeArgs #>, TResult> self, Func<<#= typeArgs #>, bool> condition, TResult defaultValue)
        {
            return MakeConditional(self, condition, (<#= args #>) => defaultValue);
        }

        public static Func<<#= typeArgs #>, TResult> MakeConditional<<#= typeArgs #>, TResult>(this Func<<#= typeArgs #>, TResult> self, Func<<#= typeArgs #>, bool> condition, Func<<#= typeArgs #>, TResult> falseFunc)
        {
            Guard.NotNull(self, "self");
            Guard.NotNull(condition, "condition");

            return (<#= args #>) =>
            {
                if (condition(<#= args #>))
                    return self(<#= args #>);

                if (falseFunc != null)
                    return falseFunc(<#= args #>);
                
                return default(TResult);
            };
        }

		public static Func<<#= typeArgs #>, TResult> Synchronize<<#= typeArgs #>, TResult>(this Func<<#= typeArgs #>, TResult> self)
        {
            return self.Synchronize((<#= args #>) => true);
        }

        public static Func<<#= typeArgs #>, TResult> Synchronize<<#= typeArgs #>, TResult>(this Func<<#= typeArgs #>, TResult> self, Func<<#= typeArgs #>, bool> needsSynchronizationPredicate)
        {
            Guard.NotNull(self, "self");
            Guard.NotNull(needsSynchronizationPredicate, "needsSynchronizationPredicate");

            var lockObject = new object();

            return (<#= args #>) =>
            {
                if(needsSynchronizationPredicate(<#= args #>))
                {
                    lock (lockObject)
                    {
                        return self(<#= args #>);
                    }
                }

                return self(<#= args #>);
            };
        }

		<# } #>

		<# foreach(var i in Enumerable.Range(1, 16))
		{
			string fullTypeArgs = Delimit(Enumerable.Range(1, i), ", ", x => "T" + x.ToString());
			string fullArgs = Delimit(Enumerable.Range(1, i), ", ", x => "t" + x.ToString());

			string nestedTupleType = "";
			string nestedTupleCreate = "";
			string nestedArgs = "";

			foreach(var batch in Batch(Enumerable.Range(1, i), 7).Reverse())
			{
				string typePrefix = "Tuple<" + Delimit(batch, ", ", x => "T" + x.ToString());

				string createPrefix = "new Tuple<" + Delimit(batch, ", ", x => "T" + x.ToString());
				string argCreatePrefix = ">(" + Delimit(batch, ", ", x => "t" + x.ToString());
				string argsList = "x" + string.Join("", Enumerable.Repeat(".Rest", batch.Index)) + Delimit(batch.Select(x => ((x - 1) % 7) + 1), ", x" + string.Join("", Enumerable.Repeat(".Rest", batch.Index)), x => ".Item" + x.ToString());


				if(string.IsNullOrWhiteSpace(nestedTupleType))
				{
					nestedTupleType = typePrefix + ">";
					nestedTupleCreate = createPrefix + argCreatePrefix + ")";
					nestedArgs = argsList;
				}
				else
				{
					nestedTupleCreate = createPrefix + ", " + nestedTupleType + argCreatePrefix + ", " + nestedTupleCreate + ")";
					nestedTupleType = typePrefix + ", " + nestedTupleType + ">";
					nestedArgs = argsList + ", " + nestedArgs;

				}
			}
	    #>

		public static Func<<#= fullTypeArgs #>, TResult> Memoize<<#= fullTypeArgs #>, TResult>(this Func<<#= fullTypeArgs #>, TResult> self)
		{
			Guard.NotNull(self, "self");
			var dictionary = new LazySelectionDictionary<<#= nestedTupleType #>, TResult>(x => self(<#= nestedArgs #>));

			return (<#= fullArgs #>) => dictionary[<#= nestedTupleCreate #>];
		}
		<# } #>
	}
}
