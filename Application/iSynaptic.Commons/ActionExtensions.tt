<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ output extension=".generated.cs" #>
<#@ include file="..\..\General.ttinclude" #>

using System;
using System.Collections.Generic;
using System.Threading;

namespace iSynaptic.Commons
{
	public static partial class ActionExtensions
	{
		<# foreach(var i in Enumerable.Range(1, 16))
		{
			string typeArgs = Delimit(Enumerable.Range(1, i), ", ", x => "T" + x.ToString());
			string args = Delimit(Enumerable.Range(1, i), ", ", x => "t" + x.ToString());

			string reverseTypeArgs = Delimit(Enumerable.Range(1, i).Reverse(), ", ", x => "T" + x.ToString());
			string reverseArgs = Delimit(Enumerable.Range(1, i).Reverse(), ", ", x => "t" + x.ToString());

			string curriedTypeArgs = Delimit(Enumerable.Range(1, i).Skip(1), ", ", x => "T" + x.ToString());
			string curriedArgs = Delimit(Enumerable.Range(1, i).Skip(1), ", ", x => "t" + x.ToString());
	    #>

		<# if(i > 1) { #>

		public static Action<<#= reverseTypeArgs #>> Flip<<#= typeArgs #>>(this Action<<#= typeArgs #>> self)
        {
            Guard.NotNull(self, "self");
            return (<#= reverseArgs #>) => self(<#= args #>);
        }

		public static Action<<#= curriedTypeArgs #>> Curry<<#= typeArgs #>>(this Action<<#= typeArgs #>> self, T1 t1)
        {
            Guard.NotNull(self, "self");
            return (<#= curriedArgs #>) => self(t1, <#= curriedArgs #>);
        }

		<# } #>

		public static Action<<#= typeArgs #>> MakeConditional<<#= typeArgs #>>(this Action<<#= typeArgs #>> self, Func<<#= typeArgs #>, bool> condition)
        {
            return MakeConditional(self, condition, null);
        }

        public static Action<<#= typeArgs #>> MakeConditional<<#= typeArgs #>>(this Action<<#= typeArgs #>> self, Func<<#= typeArgs #>, bool> condition, Action<<#= typeArgs #>> falseAction)
        {
            Guard.NotNull(self, "self");
            Guard.NotNull(condition, "condition");

            return (<#= args #>) =>
            {
                if (condition(<#= args #>))
                    self(<#= args #>);
                else if (falseAction != null)
                    falseAction(<#= args #>);
            };
        }

		public static Action<<#= typeArgs #>> FollowedBy<<#= typeArgs #>>(this Action<<#= typeArgs #>> self, Action<<#= typeArgs #>> followedBy)
        {
            if (self == null || followedBy == null)
                return self ?? followedBy;

            return (<#= args #>) =>
            {
                self(<#= args #>);
                followedBy(<#= args #>);
            };
        }

        public static Action<<#= typeArgs #>> MakeIdempotent<<#= typeArgs #>>(this Action<<#= typeArgs #>> self)
        {
            Guard.NotNull(self, "self");

            int beenExecuted = 0;

            return (<#= args #>) =>
            {
                int previousValue = Interlocked.CompareExchange(ref beenExecuted, 1, 0);

                if(previousValue == 0)
				{
                    self(<#= args #>);
					self = null;
				}
            };
        }

		public static Action<<#= typeArgs #>> CatchExceptions<<#= typeArgs #>>(this Action<<#= typeArgs #>> self)
        {
            return self.CatchExceptions(null);
        }

        public static Action<<#= typeArgs #>> CatchExceptions<<#= typeArgs #>>(this Action<<#= typeArgs #>> self, ICollection<Exception> exceptions)
        {
            Guard.NotNull(self, "self");

            return (<#= args #>) =>
            {
                Action innerAction = () => self(<#= args #>);
                innerAction = innerAction.CatchExceptions(exceptions);

                innerAction();
            };
        }

		<# } #>
	}
}