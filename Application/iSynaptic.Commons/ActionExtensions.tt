<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ output extension=".generated.cs" #>
<#@ include file="..\..\General.ttinclude" #>

using System;
using System.Collections.Generic;
using System.Threading;

namespace iSynaptic.Commons
{
    public static partial class ActionExtensions
    {
        <# foreach(var i in Enumerable.Range(1, 16))
        {
            string typeArgs = Delimit(Enumerable.Range(1, i), ", ", x => "T" + x.ToString());
            string args = Delimit(Enumerable.Range(1, i), ", ", x => "t" + x.ToString());

            string reverseTypeArgs = Delimit(Enumerable.Range(1, i).Reverse(), ", ", x => "T" + x.ToString());
            string reverseArgs = Delimit(Enumerable.Range(1, i).Reverse(), ", ", x => "t" + x.ToString());

            string curriedTypeArgs = Delimit(Enumerable.Range(1, i).Skip(1), ", ", x => "T" + x.ToString());
            string curriedArgs = Delimit(Enumerable.Range(1, i).Skip(1), ", ", x => "t" + x.ToString());
        #>

        <# if(i > 1) { #>

        public static Action<<#= reverseTypeArgs #>> Flip<<#= typeArgs #>>(this Action<<#= typeArgs #>> @this)
        {
            Guard.NotNull(@this, "@this");
            return (<#= reverseArgs #>) => @this(<#= args #>);
        }

        public static Action<<#= curriedTypeArgs #>> Curry<<#= typeArgs #>>(this Action<<#= typeArgs #>> @this, T1 t1)
        {
            Guard.NotNull(@this, "@this");
            return (<#= curriedArgs #>) => @this(t1, <#= curriedArgs #>);
        }

        <# } #>

        public static Action<<#= typeArgs #>> MakeConditional<<#= typeArgs #>>(this Action<<#= typeArgs #>> @this, Func<<#= typeArgs #>, bool> condition)
        {
            Guard.NotNull(@this, "@this");
            Guard.NotNull(condition, "condition");

            return MakeConditional(@this, condition, null);
        }

        public static Action<<#= typeArgs #>> MakeConditional<<#= typeArgs #>>(this Action<<#= typeArgs #>> @this, Func<<#= typeArgs #>, bool> condition, Action<<#= typeArgs #>> falseAction)
        {
            Guard.NotNull(@this, "@this");
            Guard.NotNull(condition, "condition");

            return (<#= args #>) =>
            {
                if (condition(<#= args #>))
                    @this(<#= args #>);
                else if (falseAction != null)
                    falseAction(<#= args #>);
            };
        }

        public static Action<<#= typeArgs #>> FollowedBy<<#= typeArgs #>>(this Action<<#= typeArgs #>> @this, Action<<#= typeArgs #>> followedBy)
        {
            if (@this == null || followedBy == null)
                return @this ?? followedBy;

            return (<#= args #>) =>
            {
                @this(<#= args #>);
                followedBy(<#= args #>);
            };
        }

        public static Action<<#= typeArgs #>> MakeIdempotent<<#= typeArgs #>>(this Action<<#= typeArgs #>> @this)
        {
            Guard.NotNull(@this, "@this");

            int beenExecuted = 0;

            return (<#= args #>) =>
            {
                int previousValue = Interlocked.CompareExchange(ref beenExecuted, 1, 0);

                if(previousValue == 0)
                {
                    @this(<#= args #>);
                    @this = null;
                }
            };
        }

        public static Action<<#= typeArgs #>> CatchExceptions<<#= typeArgs #>>(this Action<<#= typeArgs #>> @this)
        {
            Guard.NotNull(@this, "@this");
            return @this.CatchExceptions(null);
        }

        public static Action<<#= typeArgs #>> CatchExceptions<<#= typeArgs #>>(this Action<<#= typeArgs #>> @this, ICollection<Exception> exceptions)
        {
            Guard.NotNull(@this, "@this");

            return (<#= args #>) =>
            {
                Action innerAction = () => @this(<#= args #>);
                innerAction = innerAction.CatchExceptions(exceptions);

                innerAction();
            };
        }

        <# } #>
    }
}