- Add Xml comments to public API surface...
- Scan thru Reactive/Interactive Extensions for potential new/renamed Maybe<T> operators...
	* Add Retry method
- Allow Exodata bindings to bind to types of symbols, not just instances...
- Add the ability to give names to Exodata bindings for debugging purposes
- Add the ability to turn logging on for Exodata resolution
- Add the ability to resolve and bind Exodata to untyped symbols...
- Implement Equatable<T>, using same approach as Cloneable<T>...
- Enhance Cloneable<T> to detect if a struct is a cloneable primative (all fields recursively are cloneable primitives)...
- Ensure thread safety in Cloneable<T>/Equatable<T>...
- Evaluate possible refactoring of Cloneable<T>/Equatable<T> to see if they could be simplified/generalized...
- Move to .NET 4.0
	* Evaluate using Contracts class (augment or replace Guard class)
    * Replace thread safety in Cloneable<T>/Equatable<T> with Lazy<T>
- Create abstract TextScanner<T>, where T is the Token type
    * Use regular expressions to build a Table Lexer?
        ** Convert multiple regular expressions into a single recognizer state machine
- Create generic Reflection Visitor<T> implementation (similar to one used in RegularExpressionPipeline)...
- Add RelativePath extension methods to FileSystemInfo and IEnumerable<FileSystemInfo>...
- Implement SmartFormat ( e.g. SmartFormat.Format("{Name}: {Description}", new { Name = "Foo", Description = "Bar" }); )
- Add support for Dependant Scopes (e.g. System.Transactions.Transaction.DependantClone(...))
- Add support for Scopes that need to be explicitly passed around (e.g. ScopeBounds.Explicit)
	* Create Push() method to create child scope
	* Collapse CompositeDisposable into DisposableContext
- Change LookAheadValue from class to struct
- Create JSON LoggerContextSerializer
- Enhance GetDelegate extension method to work with generic methods
- Make entire library localizable via Exodata
	* Create tool that generates ExodataDeclarations from resource files
	* Create separate DependencyDeclaration (symbol) for retrieving localization ExodataResolver
- Investigate/create ISymbol and ISymbol<T> to capture "declaration" as a general concept
	* Collapse/refactor IDependencyDeclaration<T> and IExodataDeclaration<T> to use ISymbol<T>
	* Create simple SymbolTable scope that uses symbols
- Scan types for Command-Query Separation opportunities