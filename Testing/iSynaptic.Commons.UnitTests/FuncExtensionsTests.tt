<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ output extension=".generated.cs" #>
<#@ include file="..\..\General.ttinclude" #>

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

using NUnit.Framework;

namespace iSynaptic.Commons
{
    public partial class FuncExtensionsTests
    {
		<# foreach(var i in Enumerable.Range(1, 16))
		{
			string nameSuffix = Delimit(Enumerable.Range(1, i), "", x => "T" + x.ToString());
			string typeArgs = Delimit(Enumerable.Range(1, i), ", ", x => "T" + x.ToString());
			string fixedTypes = Delimit(Enumerable.Range(1, i), ", ", x => "int");
			string args = Delimit(Enumerable.Range(1, i), ", ", x => "t" + x.ToString());
			string fixedArgs = Delimit(Enumerable.Range(1, i), ", ", x => x.ToString());
	    #>

		[Test]
        public void ToActionOf<#= nameSuffix #>()
        {
            int val = 0;

            Func<<#= fixedTypes #>, int> func = (<#= args #>) => { val = <#= Delimit(Enumerable.Range(1, i), " + ", x => "t" + x.ToString()) #>; return val; };
            var action = func.ToAction();

            action(<#= fixedArgs #>);

			int expected = <#= Delimit(Enumerable.Range(1, i), " + ", x => x.ToString()) #>;
            Assert.AreEqual(expected, val);
        }

		[Test]
        public void AndOf<#= nameSuffix #>_WithNullFuncs_ThrowsArgumentNullException()
        {
            Func<<#= fixedTypes #>, bool> nullFunc = null;
            Func<<#= fixedTypes #>, bool> notNullFunc = (<#= args #>) => true;

            Assert.Throws<ArgumentNullException>(() => nullFunc.And(notNullFunc));
            Assert.Throws<ArgumentNullException>(() => notNullFunc.And(nullFunc));
        }

        [Test]
        public void AndOf<#= nameSuffix #>_WithValidFuncs_ComposesCorrectly()
        {
			bool leftResult = true;
			bool rightResult = true;

            Func<<#= fixedTypes #>, bool> left = (<#= args #>) => leftResult;
            Func<<#= fixedTypes #>, bool> right = (<#= args #>) => rightResult;

            var andFunc = left.And(right);

            Assert.IsTrue(andFunc(<#= fixedArgs #>));

			leftResult = false;
            Assert.IsFalse(andFunc(<#= fixedArgs #>));

			leftResult = true;
			rightResult = false;
            Assert.IsFalse(andFunc(<#= fixedArgs #>));
        }

        [Test]
        public void OrOf<#= nameSuffix #>_WithNullFuncs_ThrowsArgumentNullException()
        {
            Func<<#= fixedTypes #>, bool> nullFunc = null;
            Func<<#= fixedTypes #>, bool> notNullFunc = (<#= args #>) => true;

            Assert.Throws<ArgumentNullException>(() => nullFunc.Or(notNullFunc));
            Assert.Throws<ArgumentNullException>(() => notNullFunc.Or(nullFunc));
        }

        [Test]
        public void OrOf<#= nameSuffix #>_WithValidFuncs_ComposesCorrectly()
        {
            bool leftResult = true;
			bool rightResult = true;

            Func<<#= fixedTypes #>, bool> left = (<#= args #>) => leftResult;
            Func<<#= fixedTypes #>, bool> right = (<#= args #>) => rightResult;

            var orFunc = left.Or(right);

            Assert.IsTrue(orFunc(<#= fixedArgs #>));

			leftResult = false;
            Assert.IsTrue(orFunc(<#= fixedArgs #>));

			rightResult = false;
            Assert.IsFalse(orFunc(<#= fixedArgs #>));
        }

        [Test]
        public void XOrOf<#= nameSuffix #>_WithNullFuncs_ThrowsArgumentNullException()
        {
            Func<<#= fixedTypes #>, bool> nullFunc = null;
            Func<<#= fixedTypes #>, bool> notNullFunc = (<#= args #>) => true;

            Assert.Throws<ArgumentNullException>(() => nullFunc.XOr(notNullFunc));
            Assert.Throws<ArgumentNullException>(() => notNullFunc.XOr(nullFunc));
        }

        [Test]
        public void XOrOf<#= nameSuffix #>_WithValidFuncs_ComposesCorrectly()
        {
            bool leftResult = true;
			bool rightResult = true;

            Func<<#= fixedTypes #>, bool> left = (<#= args #>) => leftResult;
            Func<<#= fixedTypes #>, bool> right = (<#= args #>) => rightResult;

            var orFunc = left.XOr(right);

            Assert.IsFalse(orFunc(<#= fixedArgs #>));

			leftResult = false;
            Assert.IsTrue(orFunc(<#= fixedArgs #>));

			leftResult = true;
			rightResult = false;
            Assert.IsTrue(orFunc(<#= fixedArgs #>));

			leftResult = false;
            Assert.IsFalse(orFunc(<#= fixedArgs #>));
        }

		[Test]
		public void SynchronizeOf<#= nameSuffix #>_PreventsConcurrentAccess()
		{
			bool shouldSync = true;

			int count = 0;
            Func<<#= fixedTypes #>, int> func = (<#= args #>) => { count++; if(count == 1) { Thread.Sleep(100); } return count; };
			func = func.Synchronize((<#= args #>) => shouldSync);

            var task1 = Task.Factory.StartNew(() => func(<#= fixedArgs #>));
            var task2 = Task.Factory.StartNew(() => func(<#= fixedArgs #>));

			var results = new[]{task1, task2}.Select(x => x.Result).OrderBy(x => x);
			Assert.IsTrue(results.SequenceEqual(new[]{1, 2}));

			shouldSync = false;
			count = 0;

			task1 = Task.Factory.StartNew(() => func(<#= fixedArgs #>));
            task2 = Task.Factory.StartNew(() => func(<#= fixedArgs #>));

			results = new[]{task1, task2}.Select(x => x.Result).OrderBy(x => x);
			Assert.IsTrue(results.SequenceEqual(new[]{2, 2}));
		}

		[Test]
		public void SynchronizeOf<#= nameSuffix #>_UsesCorrectArguments()
		{
            Func<<#= fixedTypes #>, int> func = (<#= args #>) => <#= Delimit(Enumerable.Range(1, i), " + ", x => "t" + x.ToString()) #>;
			func = func.Synchronize();

			int expected = <#= Enumerable.Range(1, i).Sum().ToString() #>;
			
			Assert.AreEqual(expected, func(<#= fixedArgs #>));
		}

		[Test]
		public void MakeConditionalOf<#= nameSuffix #>()
		{
			<# string halvedFixedArgs = Delimit(Enumerable.Range(1, i), ", ", x => (x / 2).ToString()); #>

			Func<<#= fixedTypes #>, int> func = null;

            Assert.Throws<ArgumentNullException>(() => { func.MakeConditional((<#= args #>) => true); });

            func = (<#= args #>) => <#= Delimit(Enumerable.Range(1, i), " + ", x => "t" + x.ToString()) #>;
            Assert.Throws<ArgumentNullException>(() => { func.MakeConditional(null); });

			int expected = <#= Delimit(Enumerable.Range(1, i), " + ", x => x.ToString()) #>;

            var simpleConditionalFunc = func.MakeConditional((<#= args #>) => <#= Delimit(Enumerable.Range(1, i), " + ", x => "t" + x.ToString()) #> == expected);
            Assert.AreEqual(0, simpleConditionalFunc(<#= halvedFixedArgs #>));
            Assert.AreEqual(expected, simpleConditionalFunc(<#= fixedArgs #>));

            var withDefaultValueFunc = func.MakeConditional((<#= args #>) => <#= Delimit(Enumerable.Range(1, i), " + ", x => "t" + x.ToString()) #> == expected, -1);
            Assert.AreEqual(-1, withDefaultValueFunc(<#= halvedFixedArgs #>));
            Assert.AreEqual(expected, withDefaultValueFunc(<#= fixedArgs #>));

            var withFalseFunc = func.MakeConditional((<#= args #>) => <#= Delimit(Enumerable.Range(1, i), " + ", x => "t" + x.ToString()) #> == expected, (<#= args #>) => 42);
            Assert.AreEqual(42, withFalseFunc(<#= halvedFixedArgs #>));
            Assert.AreEqual(expected, withFalseFunc(<#= fixedArgs #>));
		}

		[Test]
		public void MemoizeOf<#= nameSuffix #>()
		{
			Func<<#= fixedTypes #>, int> func = null;

			Assert.Throws<ArgumentNullException>(() => { func.Memoize(); });

			int count = 0;

			int firstExpected = <#= Delimit(Enumerable.Range(1, i), " + ", x => x.ToString()) #>;
			int secondExpected = <#= Delimit(Enumerable.Range(1, i), " + ", x => (x * 2).ToString()) #>;

            func = (<#= args #>) => { count++; return <#= Delimit(Enumerable.Range(1, i), " + ", x => "t" + x.ToString()) #>; };
			func = func.Memoize();

			Assert.AreEqual(firstExpected, func(<#= fixedArgs #>));
			Assert.AreEqual(firstExpected, func(<#= fixedArgs #>));
			Assert.AreEqual(firstExpected, func(<#= fixedArgs #>));

			<# string secondFixedArgs = Delimit(Enumerable.Range(1, i), ", ", x => (x * 2).ToString()); #>

			Assert.AreEqual(secondExpected, func(<#= secondFixedArgs #>));
			Assert.AreEqual(secondExpected, func(<#= secondFixedArgs #>));
			Assert.AreEqual(secondExpected, func(<#= secondFixedArgs #>));


			Assert.AreEqual(2, count);

		}

		[Test]
        public void FollowedByOf<#= nameSuffix #>_WithNullArgument_ReturnsOriginal()
        {
            Func<<#= fixedTypes #>, Maybe<int>> originalFunc = (<#= args #>) => 42;
            var func = originalFunc.FollowedBy(null);

            var result = func(<#= fixedArgs #>);

            Assert.IsTrue(ReferenceEquals(originalFunc, func));
            Assert.AreEqual(42, result.Value);
        }

        [Test]
        public void FollowedByOf<#= nameSuffix #>_ExtendingNullFunc_ReturnsOriginal()
        {
            Func<<#= fixedTypes #>, Maybe<int>> originalFunc = (<#= args #>) => 42;
            var func = ((Func<<#= fixedTypes #>, Maybe<int>>)null).FollowedBy(originalFunc);

            var result = func(<#= fixedArgs #>);

            Assert.IsTrue(ReferenceEquals(originalFunc, func));
            Assert.AreEqual(42, result.Value);
        }

        [Test]
        public void FollowedByOf<#= nameSuffix #>_CallsFirstFunc()
        {
            Func<<#= fixedTypes #>, Maybe<int>> left = (<#= args #>) => 42;
            Func<<#= fixedTypes #>, Maybe<int>> right = (<#= args #>) => 7;

            var func = left.FollowedBy(right);

            var results = func(<#= fixedArgs #>);

            Assert.AreEqual(42, results.Value);
        }

        [Test]
        public void FollowedByOf<#= nameSuffix #>_CallsSecondFunc()
        {
            Func<<#= fixedTypes #>, Maybe<int>> left = (<#= args #>) => Maybe<int>.NoValue;
            Func<<#= fixedTypes #>, Maybe<int>> right = (<#= args #>) => 42;

            var func = left.FollowedBy(right);

            var results = func(<#= fixedArgs #>);

            Assert.AreEqual(42, results.Value);
        }

        [Test]
        public void PrecededByOf<#= nameSuffix #>_WithNullArgument_ReturnsOriginal()
        {
            Func<<#= fixedTypes #>, Maybe<int>> originalFunc = (<#= args #>) => 42;
            var func = originalFunc.PrecededBy(null);

            var result = func(<#= fixedArgs #>);

            Assert.IsTrue(ReferenceEquals(originalFunc, func));
            Assert.AreEqual(42, result.Value);
        }

        [Test]
        public void PrecededByOf<#= nameSuffix #>_ExtendingNullAction_ReturnsOriginal()
        {
            Func<<#= fixedTypes #>, Maybe<int>> originalFunc = (<#= args #>) => 42;
            var func = ((Func<<#= fixedTypes #>, Maybe<int>>)null).PrecededBy(originalFunc);

            var result = func(<#= fixedArgs #>);

            Assert.IsTrue(ReferenceEquals(originalFunc, func));
            Assert.AreEqual(42, result.Value);
        }

        [Test]
        public void PrecededByOf<#= nameSuffix #>_CallsFirstFunc()
        {
            Func<<#= fixedTypes #>, Maybe<int>> left = (<#= args #>) => 42;
            Func<<#= fixedTypes #>, Maybe<int>> right = (<#= args #>) => Maybe<int>.NoValue;

            var func = left.PrecededBy(right);

            var results = func(<#= fixedArgs #>);

            Assert.AreEqual(42, results.Value);
        }

        [Test]
        public void PrecededByOf<#= nameSuffix #>_CallsSecondFunc()
        {
            Func<<#= fixedTypes #>, Maybe<int>> left = (<#= args #>) => 7;
            Func<<#= fixedTypes #>, Maybe<int>> right = (<#= args #>) => 42;

            var func = left.PrecededBy(right);

            var results = func(<#= fixedArgs #>);

            Assert.AreEqual(42, results.Value);
        }

		<# } #>
	}
}